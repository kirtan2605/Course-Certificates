Ubuntu Pastebin
Paste from boot-repair at Mon, 18 Jan 2021 20:30:40 +0000

boot-repair-4ppa125                                              [20210119_0159]

============================== Boot Info Summary ===============================

 => Grub2 (v2.00) is installed in the MBR of /dev/sda and looks at sector 
    264740864 of the same hard drive for core.img. core.img is at this 
    location and looks for (,gpt8)/boot/grub. It also embeds following 
    components:
    
    modules
    ---------------------------------------------------------------------------
    fshelp ext2 part_gpt biosdisk
    ---------------------------------------------------------------------------

sda1: __________________________________________________________________________

    File system:       vfat
    Boot sector type:  FAT16
    Boot sector info:  No errors found in the Boot Parameter Block.
    Operating System:  
    Boot files:        

sda2: __________________________________________________________________________

    File system:       ext4
    Boot sector type:  -
    Boot sector info: 
    Operating System:  
    Boot files:        

sda3: __________________________________________________________________________

    File system:       
    Boot sector type:  -
    Boot sector info: 

sda4: __________________________________________________________________________

    File system:       vfat
    Boot sector type:  FAT32
    Boot sector info:  No errors found in the Boot Parameter Block.
    Operating System:  
    Boot files:        

sda5: __________________________________________________________________________

    File system:       vfat
    Boot sector type:  FAT32
    Boot sector info:  No errors found in the Boot Parameter Block.
    Operating System:  
    Boot files:        

sda6: __________________________________________________________________________

    File system:       vfat
    Boot sector type:  FAT32
    Boot sector info:  No errors found in the Boot Parameter Block.
    Operating System:  
    Boot files:        

sda7: __________________________________________________________________________

    File system:       vfat
    Boot sector type:  FAT32
    Boot sector info:  No errors found in the Boot Parameter Block.
    Operating System:  
    Boot files:        

sda8: __________________________________________________________________________

    File system:       ext4
    Boot sector type:  -
    Boot sector info: 
    Operating System:  Ubuntu 20.04.1 LTS
    Boot files:        /boot/grub/grub.cfg /etc/fstab /etc/default/grub 
                       /boot/grub/i386-pc/core.img

sda10: _________________________________________________________________________

    File system:       vfat
    Boot sector type:  FAT32
    Boot sector info:  No errors found in the Boot Parameter Block.
    Operating System:  
    Boot files:        

sda11: _________________________________________________________________________

    File system:       ext4
    Boot sector type:  -
    Boot sector info: 
    Operating System:  Ubuntu 20.04.1 LTS
    Boot files:        /boot/grub/grub.cfg /etc/fstab /etc/default/grub 
                       /boot/grub/i386-pc/core.img


================================ 2 OS detected =================================

OS#1:   The OS now in use - Ubuntu 20.04.1 LTS CurrentSession on sda11
OS#2:   Ubuntu 20.04.1 LTS on sda8

============================ Architecture/Host Info ============================

CPU architecture: 64-bit
BOOT_IMAGE of the installed session in use:
/boot/vmlinuz-5.4.0-54-generic root=UUID=006957ca-3a1d-4ca5-8aef-7dc4449773bf ro quiet splash


===================================== UEFI =====================================

This installed-session is not in EFI-mode.



============================= Drive/Partition Info =============================

Disks info: ____________________________________________________________________

sda	: is-GPT,	no-BIOSboot,	has-noESP, 	not-usb,	not-mmc, has-os,	2048 sectors * 512 bytes

Partitions info (1/3): _________________________________________________________

sda11	: is-os,	64, apt-get,	grub-pc ,	grub2,	grub-install,	grubenv-ok,	update-grub,	farbios
sda1	: no-os,	32, nopakmgr,	no-docgrub,	nogrub,	nogrubinstall,	no-grubenv,	noupdategrub,	not-far
sda2	: no-os,	32, nopakmgr,	no-docgrub,	nogrub,	nogrubinstall,	no-grubenv,	noupdategrub,	not-far
sda4	: no-os,	32, nopakmgr,	no-docgrub,	nogrub,	nogrubinstall,	no-grubenv,	noupdategrub,	farbios
sda5	: no-os,	32, nopakmgr,	no-docgrub,	nogrub,	nogrubinstall,	no-grubenv,	noupdategrub,	farbios
sda6	: no-os,	32, nopakmgr,	no-docgrub,	nogrub,	nogrubinstall,	no-grubenv,	noupdategrub,	farbios
sda7	: no-os,	32, nopakmgr,	no-docgrub,	nogrub,	nogrubinstall,	no-grubenv,	noupdategrub,	farbios
sda8	: is-os,	64, apt-get,	signed grub-pc grub-efi ,	grub2,	grub-install,	grubenv-ok,	update-grub,	farbios
sda10	: no-os,	32, nopakmgr,	no-docgrub,	nogrub,	nogrubinstall,	no-grubenv,	noupdategrub,	farbios
sda3	: no-os,	32, nopakmgr,	no-docgrub,	nogrub,	nogrubinstall,	no-grubenv,	noupdategrub,	not-far

Partitions info (2/3): _________________________________________________________

sda11	: isnotESP,	fstab-has-goodEFI,	no-nt,	no-winload,	no-recov-nor-hid,	no-bmgr,	notwinboot
sda1	: isnotESP,	part-has-no-fstab,	no-nt,	no-winload,	recovery-or-hidden,	no-bmgr,	notwinboot
sda2	: isnotESP,	part-has-no-fstab,	no-nt,	no-winload,	no-recov-nor-hid,	no-bmgr,	notwinboot
sda4	: isnotESP,	part-has-no-fstab,	no-nt,	no-winload,	no-recov-nor-hid,	no-bmgr,	notwinboot
sda5	: isnotESP,	part-has-no-fstab,	no-nt,	no-winload,	recovery-or-hidden,	no-bmgr,	notwinboot
sda6	: isnotESP,	part-has-no-fstab,	no-nt,	no-winload,	no-recov-nor-hid,	no-bmgr,	notwinboot
sda7	: isnotESP,	part-has-no-fstab,	no-nt,	no-winload,	no-recov-nor-hid,	no-bmgr,	notwinboot
sda8	: isnotESP,	fstab-has-bad-efi,	no-nt,	no-winload,	no-recov-nor-hid,	no-bmgr,	notwinboot
sda10	: isnotESP,	part-has-no-fstab,	no-nt,	no-winload,	no-recov-nor-hid,	no-bmgr,	notwinboot
sda3	: isnotESP,	part-has-no-fstab,	no-nt,	no-winload,	no-recov-nor-hid,	no-bmgr,	notwinboot

Partitions info (3/3): _________________________________________________________

sda11	: not-sepboot,	with-boot,	fstab-without-boot,	not-sep-usr,	with--usr,	fstab-without-usr,	std-grub.d,	sda
sda1	: not-sepboot,	no-boot,	part-has-no-fstab,	not-sep-usr,	no---usr,	part-has-no-fstab,	std-grub.d,	sda
sda2	: maybesepboot,	no-boot,	part-has-no-fstab,	not-sep-usr,	no---usr,	part-has-no-fstab,	std-grub.d,	sda
sda4	: not-sepboot,	no-boot,	part-has-no-fstab,	not-sep-usr,	no---usr,	part-has-no-fstab,	std-grub.d,	sda
sda5	: not-sepboot,	no-boot,	part-has-no-fstab,	not-sep-usr,	no---usr,	part-has-no-fstab,	std-grub.d,	sda
sda6	: not-sepboot,	no-boot,	part-has-no-fstab,	not-sep-usr,	no---usr,	part-has-no-fstab,	std-grub.d,	sda
sda7	: not-sepboot,	no-boot,	part-has-no-fstab,	not-sep-usr,	no---usr,	part-has-no-fstab,	std-grub.d,	sda
sda8	: not-sepboot,	with-boot,	fstab-without-boot,	not-sep-usr,	with--usr,	fstab-without-usr,	customized,	sda
sda10	: not-sepboot,	no-boot,	part-has-no-fstab,	not-sep-usr,	no---usr,	part-has-no-fstab,	std-grub.d,	sda
sda3	: maybesepboot,	no-boot,	part-has-no-fstab,	not-sep-usr,	no---usr,	part-has-no-fstab,	std-grub.d,	sda

fdisk -l (filtered): ___________________________________________________________

Disk sda: 465.78 GiB, 500107862016 bytes, 976773168 sectors
Disk identifier: 8CDEC0CA-F192-5D49-8241-C924F189916D
          Start       End   Sectors   Size Type
sda1       2048    923647    921600   450M Microsoft basic data
sda2     923648   1128447    204800   100M Linux filesystem
sda3    1128448   1140735     12288     6M Linux filesystem
sda4    1161216 264739914 263578699 125.7G Microsoft basic data
sda5  305496064 307199188   1703125 831.6M Microsoft basic data
sda6  307202048 614402047 307200000 146.5G Microsoft basic data
sda7  614402048 823173119 208771072  99.6G Microsoft basic data
sda8  823173120 976771071 153597952  73.2G Linux filesystem
sda10 264742912 265793535   1050624   513M Microsoft basic data
sda11 265793536 305496063  39702528    19G Linux filesystem
Partition table entries are not in disk order.

parted -lm (filtered): _________________________________________________________

sda:500GB:scsi:512:4096:gpt:ATA WDC WD5000LPVX-7:;
1:1049kB:473MB:472MB:fat16:Basic data partition:hidden, msftdata;
2:473MB:578MB:105MB:ext4:Linux filesystem:;
3:578MB:584MB:6291kB:::;
4:595MB:136GB:135GB:fat32:Basic data partition:msftdata;
10:136GB:136GB:538MB:fat32::msftdata;
11:136GB:156GB:20.3GB:ext4::;
5:156GB:157GB:872MB:fat32::hidden, msftdata;
6:157GB:315GB:157GB:fat32:Basic data partition:msftdata;
7:315GB:421GB:107GB:fat32:Basic data partition:msftdata;
8:421GB:500GB:78.6GB:ext4::;

blkid (filtered): ______________________________________________________________

NAME    FSTYPE   UUID                                 PARTUUID                             LABEL PARTLABEL
sda                                                                                              
├─sda1  vfat     8A82-E840                            424a42a7-65c2-4043-a5d1-d1b3c89d0d4b       Basic data partition
├─sda2  ext4     28d17233-6673-4bad-be60-96f21de5a7eb c80a736e-58d8-4cb5-908b-c51aa55c8cad       Linux filesystem
├─sda3                                                e9bbb147-868e-479f-a6a6-a6230e72a76c       
├─sda4  vfat     11DB-E4E3                            3adb2830-22b4-4670-97e8-f3247f63b161       Basic data partition
├─sda5  vfat     88AA-9680                            bf69f87f-2a1e-4960-87de-5289d67c16a2       
├─sda6  vfat     F9BA-3AE6                            aefb796c-7137-4c75-8819-2fa5bf2cb2b4       Basic data partition
├─sda7  vfat     2A9C-C824                            358711eb-a6d0-402c-bbd2-d661b0245b17       Basic data partition
├─sda8  ext4     355877ac-471e-4427-9175-52b7b339dc00 3caa1017-56b5-43e7-93a8-c7a1d720830c       
├─sda10 vfat     E306-40CD                            9b668c5b-4970-4ebc-8561-04ed6ac9b8a1       
└─sda11 ext4     006957ca-3a1d-4ca5-8aef-7dc4449773bf fb1877a7-a987-46b8-8f46-6422456cca1b       

df (filtered): _________________________________________________________________

                   Avail Use% Mounted on
sda11               8.6G  49% /
sda1              449.8M   0% /mnt/boot-sav/sda1
sda2               85.8M   0% /mnt/boot-sav/sda2
sda4              123.3G   2% /mnt/boot-sav/sda4
sda5                830M   0% /mnt/boot-sav/sda5
sda6              136.5G   7% /mnt/boot-sav/sda6
sda7               64.9G  35% /mnt/boot-sav/sda7
sda8               41.9G  36% /mnt/boot-sav/sda8

Mount options: __________________________________________________________________

sda11             rw,relatime,errors=remount-ro
sda1              rw,relatime,fmask=0022,dmask=0022,codepage=437,iocharset=iso8859-1,shortname=mixed,errors=remount-ro
sda2              rw,relatime
sda4              rw,relatime,fmask=0022,dmask=0022,codepage=437,iocharset=iso8859-1,shortname=mixed,errors=remount-ro
sda5              rw,relatime,fmask=0022,dmask=0022,codepage=437,iocharset=iso8859-1,shortname=mixed,errors=remount-ro
sda6              rw,relatime,fmask=0022,dmask=0022,codepage=437,iocharset=iso8859-1,shortname=mixed,errors=remount-ro
sda7              rw,relatime,fmask=0022,dmask=0022,codepage=437,iocharset=iso8859-1,shortname=mixed,errors=remount-ro
sda8              rw,relatime

====================== sda8/boot/grub/grub.cfg (filtered) ======================

Ubuntu   355877ac-471e-4427-9175-52b7b339dc00
Ubuntu, with Linux 5.4.0-62-generic   355877ac-471e-4427-9175-52b7b339dc00
Ubuntu, with Linux 5.4.0-60-generic   355877ac-471e-4427-9175-52b7b339dc00
Ubuntu, with Linux 5.4.0-59-generic   355877ac-471e-4427-9175-52b7b339dc00
Ubuntu 20.04.1 LTS (20.04) (on sda11)   006957ca-3a1d-4ca5-8aef-7dc4449773bf
Ubuntu (on sda11)   006957ca-3a1d-4ca5-8aef-7dc4449773bf
Ubuntu, with Linux 5.4.0-54-generic (on sda11)   006957ca-3a1d-4ca5-8aef-7dc4449773bf
Ubuntu, with Linux 5.4.0-42-generic (on sda11)   006957ca-3a1d-4ca5-8aef-7dc4449773bf

========================== sda8/etc/fstab (filtered) ===========================

# <file system> <mount point>   <type>  <options>       <dump>  <pass>
# / was on /dev/sda8 during installation
UUID=355877ac-471e-4427-9175-52b7b339dc00 /               ext4    errors=remount-ro 0       1
# /boot/efi was on /dev/sda2 during installation
UUID=9C2C-3A15  /boot/efi       vfat    umask=0077      0       1
/swapfile                                 none            swap    sw              0       0

======================= sda8/etc/default/grub (filtered) =======================

GRUB_DEFAULT="0"
GRUB_TIMEOUT_STYLE="hidden"
GRUB_TIMEOUT=5
GRUB_DISTRIBUTOR="`lsb_release -i -s 2> /dev/null || echo Debian`"
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=""
export GRUB_COLOR_NORMAL="light-gray/black"
export GRUB_COLOR_HIGHLIGHT="magenta/black"
GRUB_SAVEDEFAULT="false"
==================== sda8: Location of files loaded by Grub ====================

           GiB - GB             File                                 Fragment(s)
 421.759765625 = 452.861100032  boot/grub/grub.cfg                             3
 399.532520294 = 428.994777088  boot/grub/i386-pc/core.img                     1
 415.741352081 = 446.398877696  boot/vmlinuz                                   1
 439.835102081 = 472.269344768  boot/vmlinuz-5.4.0-59-generic                  2
 418.296039581 = 449.141952512  boot/vmlinuz-5.4.0-60-generic                  2
 415.741352081 = 446.398877696  boot/vmlinuz-5.4.0-62-generic                  1
 418.296039581 = 449.141952512  boot/vmlinuz.old                               2
 428.125370026 = 459.696115712  boot/initrd.img                                3
 413.978511810 = 444.506042368  boot/initrd.img-5.4.0-59-generic               2
 416.058311462 = 446.739210240  boot/initrd.img-5.4.0-60-generic               6
 428.125370026 = 459.696115712  boot/initrd.img-5.4.0-62-generic               3
 416.058311462 = 446.739210240  boot/initrd.img.old                            6

===================== sda8: ls -l /etc/grub.d/ (filtered) ======================

-rwxr-xr-x 1 root root   113 Nov 16 10:11 10_linux_proxy
-rwxr-xr-x 1 root root   157 Nov 16 10:11 31_linux_proxy
-rwxr-xr-x 1 root root 42359 Sep  8 15:54 33_linux_zfs
-rwxr-xr-x 1 root root 12894 Sep  8 15:54 34_linux_xen
-rwxr-xr-x 1 root root  1992 Jan 28  2016 35_memtest86+
-rwxr-xr-x 1 root root 12059 Mar 18  2019 36_os-prober
-rwxr-xr-x 1 root root  1424 Sep  8 15:54 37_uefi-firmware
-rwxr-xr-x 1 root root   214 Mar 18  2019 40_custom
-rwxr-xr-x 1 root root   216 Mar 18  2019 41_custom
drwxr-xr-x 4 root root  4096 Nov 12 22:12 backup
drwxr-xr-x 2 root root  4096 Nov 12 22:12 bin
drwxr-xr-x 2 root root  4096 Nov 16 10:11 proxifiedScripts

======================== sda8/etc/grub.d/31_linux_proxy ========================

#!/bin/sh
#THIS IS A GRUB PROXY SCRIPT
'/etc/grub.d/proxifiedScripts/linux' | /etc/grub.d/bin/grubcfg_proxy "-*
+'SUBMENU' as 'Advanced options for Ubuntu'
"

========================= sda8/etc/grub.d/33_linux_zfs =========================

#! /bin/sh
set -e
# grub-mkconfig helper script.
# Copyright (C) 2019 Canonical Ltd.
#
# GRUB is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# GRUB is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
prefix="/usr"
datarootdir="/usr/share"
ubuntu_recovery="1"
quiet_boot="1"
quick_boot="1"
gfxpayload_dynamic="1"
vt_handoff="1"
. "${pkgdatadir}/grub-mkconfig_lib"
export TEXTDOMAIN=grub
export TEXTDOMAINDIR="${datarootdir}/locale"
set -u
## Skip early if zfs utils isn't installed (instead of failing on first zpool list)
if ! `which zfs >/dev/null 2>&1`; then
    exit 0
fi
imported_pools=""
MNTDIR="$(mktemp -d ${TMPDIR:-/tmp}/zfsmnt.XXXXXX)"
ZFSTMP="$(mktemp -d ${TMPDIR:-/tmp}/zfstmp.XXXXXX)"
machine="$(uname -m)"
case "${machine}" in
    i?86) GENKERNEL_ARCH="x86" ;;
    mips|mips64) GENKERNEL_ARCH="mips" ;;
    mipsel|mips64el) GENKERNEL_ARCH="mipsel" ;;
    arm*) GENKERNEL_ARCH="arm" ;;
    *) GENKERNEL_ARCH="${machine}" ;;
esac
RC=0
on_exit() {
    # Restore initial zpool import state
    for pool in ${imported_pools}; do
        zpool export "${pool}"
    done
    mountpoint -q "${MNTDIR}"  && umount "${MNTDIR}" || true
    rmdir "${MNTDIR}"
    rm -rf "${ZFSTMP}"
    exit "${RC}"
}
trap on_exit EXIT INT QUIT ABRT PIPE TERM
# List ONLINE and DEGRADED pools
import_pools() {
    # We have to ignore zpool import output, as potentially multiple / will be available,
    # and we need to autodetect all zpools this way with their real mountpoints.
    local initial_pools="$(zpool list | awk '{if (NR>1) print $1}')"
    local all_pools=""
    local imported_pools=""
    local err=""
    set +e
    err="$(zpool import -f -a -o cachefile=none -o readonly=on -N 2>&1)"
    # Only print stderr if the command returned an error
    # (it can echo "No zpool to import" with success, which we don't want)
    if [ $? -ne 0 ]; then
        echo "Some pools couldn't be imported and will be ignored:\n${err}" >&2
    fi
    set -e
    all_pools="$(zpool list | awk '{if (NR>1) print $1}')"
    for pool in ${all_pools}; do
        if echo "${initial_pools}" | grep -wq "${pool}"; then
            continue
        fi
        imported_pools="${imported_pools} ${pool}"
    done
    echo "${imported_pools}"
}
# List all the dataset with a root mountpoint
get_root_datasets() {
    local pools="$(zpool list | awk '{if (NR>1) print $1}')"
    for p in ${pools}; do
        local rel_pool_root=$(zpool get -H altroot ${p} | awk '{print $3}')
        if [ "${rel_pool_root}" = "-" ]; then
            rel_pool_root="/"
        fi
        zfs list -H -o name,canmount,mountpoint -t filesystem | grep -E '^'"${p}"'(\s|/[[:print:]]*\s)(on|noauto)\s'"${rel_pool_root}"'$' | awk '{print $1}'
    done
}
# find if given datasets can be mounted for directory and return its path (snapshot or real path)
# $1 is our current dataset name
# $2 directory path we look for (cannot contains /)
# $3 is the temporary mount directory to use
# $4 is the optional snapshot name
# return path for directory (which can be a mountpoint)
validate_system_dataset() {
    local dataset="$1"
    local directory="$2"
    local mntdir="$3"
    local snapshot_name="$4"
    local mount_path="${mntdir}/${directory}"
    if ! zfs list "${dataset}" >/dev/null 2>&1; then
        return
    fi
    if ! mount -o noatime,zfsutil -t zfs "${dataset}" "${mount_path}"; then
        grub_warn "Failed to find a valid directory '${directory}' for dataset '${dataset}@${snapshot_name}'. Ignoring"
        return
    fi
    local candidate_path="${mount_path}"
    if [ -n "${snapshot_name}" ]; then
        # WORKAROUND a bug https://github.com/zfsonlinux/zfs/issues/9958
        # Reading the content of a snapshot fails if it is not the first mount
        # for a given dataset
        first_mntdir=$(awk '{if ($1 == "'${dataset}'") {print $2; exit;}}' /proc/mounts)
        if [ "${first_mntdir}" = "/" ]; then
            # prevents // on candidate_path
            first_mntdir=""
        fi
        candidate_path="${first_mntdir}/.zfs/snapshot/${snapshot_name}"
    fi
    if [ -n "$(ls ${candidate_path} 2>/dev/null)" ]; then
        echo "${candidate_path}"
        return
    else
        mountpoint -q "${mount_path}" && umount "${mount_path}" || true
    fi
}
# Detect system directory relevant to the other, trying to find the ones associated on the current dataset or snapshot/
# System directory should be at most a direct child dataset of main datasets (no recursivity)
# We can fallback trying other zfs pools if no match has been found.
# $1 is our current dataset name (which can have @snapshot name)
# $2 directory path we look for (cannot contains /)
# $3 restrict_to_same_pool (true|false) force looking for dataset with the same basename in the current dataset pool only
# $4 is the temporary mount directory to use
# $5 is the optional etc directory (if not $2 is not etc itself)
# return path for directory (which can be a mountpoint)
get_system_directory() {
    local dataset_path="$1"
    local directory="$2"
    local restrict_to_same_pool="$3"
    local mntdir="$4"
    local etc_dir="$5"
    if [ -z "${etc_dir}" ]; then
        etc_dir="${mntdir}/etc"
    fi
    local candidate_path="${mntdir}/${directory}"
    # 1. Look for /etc/fstab first (which will mount even on top of non empty $directory)
    local mounted_fstab_entry="false"
    if [ -f "${etc_dir}/fstab" ]; then
        mount_args=$(awk '/^[^#].*[ \t]\/'"${directory}"'[ \t]/ {print "-t", $3, $1}' "${etc_dir}/fstab")
        if [ -n "${mount_args}" ]; then
            mounted_fstab_entry="true"
            mount -o noatime ${mount_args} "${candidate_path}" || mounted_fstab_entry="false"
        fi
    fi
    # If directory isn't empty. Only count if coming from /etc/fstab. Will be
    # handled below otherwise as we are interested in potential snapshots.
    if [ "${mounted_fstab_entry}" = "true" -a -n "$(ls ${candidate_path} 2>/dev/null)" ]; then
        echo "${candidate_path}"
        return
    fi
    # 2. Handle zfs case, which can be a snapshots.
    local base_dataset_path="${dataset_path}"
    local snapshot_name=""
    # For snapshots we extract the parent dataset
    if echo "${dataset_path}" | grep -q '@'; then
        base_dataset_path=$(echo "${dataset_path}" | cut -d '@' -f1)
        snapshot_name=$(echo "${dataset_path}" | cut -d '@' -f2)
    fi
    base_dataset_name="${base_dataset_path##*/}"
    base_pool="$(echo "${base_dataset_path}" | cut -d'/' -f1)"
    # 2.a) Look for child dataset included in base dataset, which needs to hold same snapshot if any
    candidate_path=$(validate_system_dataset "${base_dataset_path}/${directory}" "${directory}" "${mntdir}" "${snapshot_name}")
    if [ -n "${candidate_path}" ]; then
        echo "${candidate_path}"
        return
    fi
    # 2.b) Look for current dataset (which is already mounted as /)
    candidate_path="${mntdir}/${directory}"
    if [ -n "${snapshot_name}" ]; then
        # WORKAROUND a bug https://github.com/zfsonlinux/zfs/issues/9958
        # Reading the content of a snapshot fails if it is not the first mount
        # for a given dataset
        first_mntdir=$(awk '{if ($1 == "'${base_dataset_path}'") {print $2; exit;}}' /proc/mounts)
        if [ "${first_mntdir}" = "/" ]; then
            # prevents // on candidate_path
            first_mntdir=""
        fi
        candidate_path="${first_mntdir}/.zfs/snapshot/${snapshot_name}/${directory}"
    fi
    if [ -n "$(ls ${candidate_path} 2>/dev/null)" ]; then
        echo "${candidate_path}"
        return
    fi
    # 2.c) Look for every datasets in every pool which isn't the current dataset which holds:
    # - the same dataset name (last section) than our base_dataset_name
    # - mountpoint=directory
    # - canmount!=off
    all_same_base_dataset_name="$(zfs list -H -t filesystem -o name,canmount | awk '/^[^ ]+\/'"${base_dataset_name}"'[ \t](on|noauto)/ {print $1}') "
    # order by local pool datasets first
    current_pool_same_base_datasets=""
    other_pools_same_base_datasets=""
    root_pool=$(echo "${dataset_path%%/*}")
    for d in ${all_same_base_dataset_name}; do
        cur_dataset_pool=$(echo "${d%%/*}")
        if echo "${cur_dataset_pool}" | grep -wq "${root_pool}" 2>/dev/null ; then
            current_pool_same_base_datasets="${current_pool_same_base_datasets} ${d}"
        else
            other_pools_same_base_datasets="${other_pools_same_base_datasets} ${d}"
        fi
    done
    ordered_same_base_datasets="${current_pool_same_base_datasets} ${other_pools_same_base_datasets}"
    if [ "${restrict_to_same_pool}" = "true" ]; then
        ordered_same_base_datasets="${current_pool_same_base_datasets}"
    fi
    # now, loop over them
    for d in ${ordered_same_base_datasets}; do
        cur_dataset_pool=$(echo "${d%%/*}")
        rel_pool_root=$(zpool get -H altroot ${cur_dataset_pool} | awk '{print $3}')
        if [ "${rel_pool_root}" = "-" ]; then
            rel_pool_root=""
        fi
        # check mountpoint match
        candidate_dataset=$(zfs get -H mountpoint ${d} | grep -E "mountpoint\s${rel_pool_root}/${directory}\s" | awk '{print $1}')
        if [ -z "${candidate_dataset}" ]; then
            continue
        fi
        candidate_path=$(validate_system_dataset "${candidate_dataset}" "${directory}" "${mntdir}" "${snapshot_name}")
        if [ -n "${candidate_path}" ]; then
            echo "${candidate_path}"
            return
        fi
    done
    # 2.d) If we didn't find anything yet: check for persistent datasets corresponding to our mountpoint, with canmount=on without any snapshot associated:
    # Note: we go over previous datasets as well, but this is ok, as we didn't include them before.
    all_mountable_datasets="$(zfs list -t filesystem -o name,canmount | awk  '/^[^ ]+[ \t]+on/ {print $1}')"
    # order by local pool datasets first
    current_pool_datasets=""
    other_pools_datasets=""
    root_pool=$(echo "${dataset_path%%/*}")
    for d in ${all_mountable_datasets}; do
        cur_dataset_pool=$(echo "${d%%/*}")
        if echo "${cur_dataset_pool}" | grep -wq "${root_pool}" 2>/dev/null ; then
            current_pool_datasets="${current_pool_datasets} ${d}"
        else
            other_pools_datasets="${other_pools_datasets} ${d}"
        fi
    done
    ordered_datasets="${current_pool_datasets} ${other_pools_datasets}"
    if [ "${restrict_to_same_pool}" = "true" ]; then
        ordered_datasets="${current_pool_datasets}"
    fi
    for d in ${ordered_datasets}; do
        cur_dataset_pool=$(echo "${d%%/*}")
        rel_pool_root=$(zpool get -H altroot ${cur_dataset_pool} | awk '{print $3}')
        if [ "${rel_pool_root}" = "-" ]; then
            rel_pool_root=""
        fi
        # check mountpoint match
        candidate_dataset=$(zfs get -H mountpoint ${d} | grep -E "mountpoint\s${rel_pool_root}/${directory}\s" | awk '{print $1}')
        if [ -z "${candidate_dataset}" ]; then
            continue
        fi
        candidate_path=$(validate_system_dataset "${d}" "${directory}" "${mntdir}" "")
        if [ -n "${candidate_path}" ]; then
            echo "${candidate_path}"
            return
        fi
    done
    grub_warn "Failed to find a valid directory '${directory}' for dataset '${dataset_path}'. Ignoring"
    return
}
# Try our default layout bpool as a prefered layout (fast path)
# This is get_system_directory for boot optimized for our default installation layout
# $1 is our current dataset name (which can have @snapshot name)
# $2 is the temporary mount directory to use
# return path for directory (which can be a mountpoint) if found
try_default_layout_bpool() {
    local root_dataset_path="$1"
    local mntdir="$2"
    dataset_basename="${root_dataset_path##*/}"
    candidate_dataset="bpool/BOOT/${dataset_basename}"
    dataset_properties="$(zfs get -H mountpoint,canmount ${candidate_dataset} | cut -f3 | paste -sd ' ')"
    if [ -z "${dataset_properties}" ]; then
        return
    fi
    rel_pool_root=$(zpool get -H altroot bpool | awk '{print $3}')
    if [ "${rel_pool_root}" = "-" ]; then
        rel_pool_root=""
    fi
    snapshot_name="${dataset_basename##*@}"
    [ "${snapshot_name}" = "${dataset_basename}" ] && snapshot_name=""
    if [ -z "${snapshot_name}" ]; then
        if ! echo "${dataset_properties}" | grep -Eq "${rel_pool_root}/boot (on|noauto)"; then
            return
        fi
    else
        candidate_dataset=$(echo "${candidate_dataset}" | cut -d '@' -f1)
    fi
    validate_system_dataset "${candidate_dataset}" "boot" "${mntdir}" "${snapshot_name}"
}
# Return if secure boot is enabled on that system
is_secure_boot_enabled() {
    if LANG=C mokutil --sb-state 2>/dev/null | grep -qi enabled; then
        echo "true"
        return
    fi
    echo "false"
    return
}
# Given a filesystem or snapshot dataset, returns dataset|machine id|pretty name|last used
# $1 is dataset we want information from
# $2 is the temporary mount directory to use
get_dataset_info() {
    local dataset="$1"
    local mntdir="$2"
    local base_dataset="${dataset}"
    local etc_dir="${mntdir}/etc"
    local is_snapshot="false"
    # For snapshot we extract the parent dataset
    if echo "${dataset}" | grep -q '@'; then
        base_dataset=$(echo "${dataset}" | cut -d '@' -f1)
        is_snapshot="true"
    fi
    mount -o noatime,zfsutil -t zfs "${base_dataset}" "${mntdir}"
    # read machine-id/os-release from /etc
    etc_dir=$(get_system_directory "${dataset}" "etc" "true" "${mntdir}" "")
    if [ -z  "${etc_dir}" ]; then
        grub_warn "Ignoring ${dataset}"
        mountpoint -q "${mntdir}/etc" && umount "${mntdir}/etc" || true
        umount "${mntdir}"
        return
    fi
    machine_id=""
    if [ -f "${etc_dir}/machine-id" ]; then
        machine_id=$(cat "${etc_dir}/machine-id")
    fi
    # We have to use a random temporary id if we don't have any machine-id file or if this one is empty
    # (mostly the case of new installations before first boot).
    # Let's use the dataset name directly for this.
    # Consequence is that all datasets are then separated.
    if [ -z "${machine_id}" ]; then
        machine_id="${dataset}"
    fi
    pretty_name=$(. "${etc_dir}/os-release" && echo "${PRETTY_NAME}")
    mountpoint -q "${mntdir}/etc" && umount "${mntdir}/etc" || true
    # read available kernels from /boot
    boot_dir="$(try_default_layout_bpool "${dataset}" "${mntdir}")"
    if [ -z "${boot_dir}" ]; then
        boot_dir=$(get_system_directory "${dataset}" "boot" "false" "${mntdir}" "${etc_dir}")
    fi
    if [ -z  "${boot_dir}" ]; then
        grub_warn "Ignoring ${dataset}"
        mountpoint -q "${mntdir}/boot" && umount "${mntdir}/boot" || true
        umount "${mntdir}"
        return
    fi
    initrd_list=""
    kernel_list=""
    list=$(find "${boot_dir}" -maxdepth 1 -type f -regex '.*/\(vmlinuz\|vmlinux\|kernel\)-.*')
    while [ "x$list" != "x" ] ; do
        linux=`version_find_latest $list`
        list=`echo $list | tr ' ' '\n' | fgrep -vx "$linux" | tr '\n' ' '`
        if ! grub_file_is_not_garbage "${linux}" ; then
            continue
        fi
        # Filters entry if efi/non efi.
        # Note that for now we allow kernel without .efi.signed as those are signed kernel
        # on ubuntu, loaded by the shim.
        case "${linux}" in
            *.efi.signed)
                if [ "$(is_secure_boot_enabled)" = "false" ]; then
                    continue
                fi
            ;;
        esac
        linux_basename=$(basename "${linux}")
        linux_dirname=$(dirname "${linux}")
        version=$(echo "${linux_basename}" | sed -e "s,^[^0-9]*-,,g")
        alt_version=$(echo "${version}" | sed -e "s,\.old$,,g")
        gettext_printf "Found linux image: %s in %s\n" "${linux_basename}" "${dataset}" >&2
        initrd=""
        for i in "initrd.img-${version}" "initrd-${version}.img" "initrd-${version}.gz" \
            "initrd-${version}" "initramfs-${version}.img" \
            "initrd.img-${alt_version}" "initrd-${alt_version}.img" \
            "initrd-${alt_version}" "initramfs-${alt_version}.img" \
            "initramfs-genkernel-${version}" \
            "initramfs-genkernel-${alt_version}" \
            "initramfs-genkernel-${GENKERNEL_ARCH}-${version}" \
            "initramfs-genkernel-${GENKERNEL_ARCH}-${alt_version}"; do
            if test -e "${linux_dirname}/${i}" ; then
                initrd="$i"
                break
            fi
        done
        if test -z "${initrd}" ; then
            grub_warn "Couldn't find any valid initrd for dataset ${dataset}."
            continue
        fi
        gettext_printf "Found initrd image: %s in %s\n" "${initrd}" "${dataset}" >&2
        rel_linux_dirname=$(make_system_path_relative_to_its_root "${linux_dirname}")
        initrd_list="${initrd_list}|${rel_linux_dirname}/${initrd}"
        kernel_list="${kernel_list}|${rel_linux_dirname}/${linux_basename}"
    done
    initrd_list="${initrd_list#|}"
    kernel_list="${kernel_list#|}"
    initrd_device=$(${grub_probe} --target=device "${boot_dir}" | head -1)
    mountpoint -q "${mntdir}/boot" && umount "${mntdir}/boot" || true
    # We needed to look in / for snapshots on root dataset, umount there before zfs lazily unmount it
    case "${boot_dir}" in /boot/.zfs/snapshot/*)
        umount "${boot_dir}" || true
        ;;
    esac
    # for zsys snapshots: we want to know which kernel we successful last booted with
    last_booted_kernel=$(zfs get -H com.ubuntu.zsys:last-booted-kernel "${dataset}" | awk '{print $3}')
    # snapshot: last_used is dataset creation time
    if [ "${is_snapshot}" = "true" ]; then
        last_used="$(zfs get -pH creation "${dataset}" | awk -F '\t' '{print $3}')"
    # otherwise, last_used is manually marked at boot/shutdown on a root dataset for zsys
    else
        # if current system, take current time
        if zfs mount | awk '/[ \t]+\/$/ {print $1}' | grep -q ${dataset}; then
            last_used=$(date +%s)
        else
            last_used=$(zfs get -H com.ubuntu.zsys:last-used "${dataset}" | awk '{print $3}')
            # case of non zsys, or zsys without annotation, take /etc/machine-id stat (as we mounted with noatime).
            # However, as systems can be relatime, if system is current mounted one, set current time (case of clone + reboot
            # within the same d).
            if [ "${last_used}" = "-" ]; then
                last_used=$(stat --printf="%X" "${mntdir}/etc/os-release")
                if [ -f "${mntdir}/etc/machine-id" ]; then
                    last_used=$(stat --printf="%X" "${mntdir}/etc/machine-id")
                fi
            fi
        fi
    fi
    is_zsys=$(zfs get -H com.ubuntu.zsys:bootfs "${base_dataset}" | awk '{print $3}')
    if [ -n "${initrd_list}" -a -n "${kernel_list}" ]; then
        echo "${dataset}\t${is_zsys}\t${machine_id}\t${pretty_name}\t${last_used}\t${initrd_device}\t${initrd_list}\t${kernel_list}\t${last_booted_kernel}"
    else
        grub_warn "didn't find any valid initrd or kernel."
    fi
    umount "${mntdir}" || true
    # We needed to look in / for snapshots on root dataset, umount the snapshot for etc before zfs lazily unmount it
    case "${etc_dir}" in /.zfs/snapshot/*/etc)
        snapshot_path="$(findmnt -n -o TARGET -T ${etc_dir})"
        umount "${snapshot_path}" || true
        ;;
    esac
}
# Scan available boot options and returns in a formatted list
# $1 is the temporary mount directory to use
bootlist() {
    local mntdir="$1"
    local boot_list=""
    for dataset in $(get_root_datasets); do
        # get information from current root dataset
        boot_list="${boot_list}$(get_dataset_info ${dataset} ${mntdir})\n"
        # get information from snapshots of this root dataset
        for snapshot_dataset in $(zfs list -H -o name -t snapshot "${dataset}"); do
            boot_list="${boot_list}$(get_dataset_info ${snapshot_dataset} ${mntdir})\n"
        done
    done
    echo "${boot_list}"
}
# Order machine ids by last_used from their main entry
get_machines_sorted() {
    local bootlist="$1"
    local machineids="$(echo "${bootlist}" | awk '{print $3}' | sort -u)"
    for machineid in ${machineids}; do
        echo "${bootlist}" | awk 'BEGIN{FS="\t"} $1 !~ /.*@.*/  {print $5, $3}' | sort -nr | grep -E "[^^]\b${machineid}\b" | head -1
    done | sort -nr | awk '{print $2}'
}
# Sort entries by last_used for a given machineid
sort_entries_for_machineid() {
    local bootlist="$1"
    local machineid="$2"
    tab="$(printf '\t')"
    echo "${bootlist}" | grep -E "[^^]\b${machineid}\b" | sort -k5,5r -k1,1 -t "${tab}"
}
# Return main entry index
get_main_entry() {
    local entries="$1"
    echo "${entries}" | awk 'BEGIN{FS="\t"} $1 !~ /.*@.*/  {print}' | head -1
}
# Return specific field at index from entry
get_field_from_entry() {
    local entry="$1"
    local index="$2"
    echo "${entry}" | awk "BEGIN{FS=\"\t\"} {print \$$index}"
}
# Get the main entry metadata
main_entry_meta() {
    local main_entry="$1"
    initrd=$(get_field_from_entry "${main_entry}" 7 | cut -d'|' -f1)
    kernel=$(get_field_from_entry "${main_entry}" 8 | cut -d'|' -f1)
    # Take first element (most recent entry) which is not a snapshot
    echo "${main_entry}" | awk "BEGIN{ FS=\"\t\"; OFS=\"\t\"} {print \$3, \$2, \"main\", \$4, \$1, \$6, \"$initrd\", \"$kernel\"}"
}
# Get advanced entries metadata
advanced_entries_meta() {
    local main_entry="$1"
    last_used_kernel="$(get_field_from_entry "${main_entry}" 9 )"
    # We must align initrds with kernels.
    # Adds initrds to the stack then pop them 1 by 1 as we process the kernels
    set -- $(get_field_from_entry "${main_entry}" 7 | tr "|" " ")
    for kernel in $(get_field_from_entry "${main_entry}" 8 | tr "|" " "); do
        # get initrd and pop to the next one
        initrd="$1"; shift
        was_last_used_kernel="false"
        kernel_basename=$(basename "${kernel}")
        if [ "${kernel_basename}" = "${last_used_kernel}" ]; then
            was_last_used_kernel="true"
        fi
        echo "${main_entry}" | awk "BEGIN{ FS=\"\t\"; OFS=\"\t\"}    {print \$3, \$2, \"advanced\", \$4, \$1, \$6, \"$initrd\", \"$kernel\", \"$was_last_used_kernel\"}"
    done
}
# Get history metadata
history_entries_meta() {
    local entries="$1"
    local main_dataset_name="$2"
    local main_dataset_releasename="$3"
    if [ -z "${entries}" ]; then
        return
    fi
    # Traverse snapshots and clones
    echo "${entries}" | while read entry; do
        name=""
        # Compute snapshot/filesystem dataset name
        snap_dataset_name="$(get_field_from_entry "${entry}" 1)"
        snapname="${snap_dataset_name##*@}"
        # If, this is a clone, take what is after main_dataset_name
        if [ "${snapname}" = "${snap_dataset_name}" ]; then
            snapname="${snap_dataset_name##${main_dataset_name}_}"
            # Handle manual user clone (not prefixed by "main_dataset_name")
            snapname="${snapname##*/}"
        fi
        # We keep the snapname only if it is not only a zsys auto snapshot
        if echo "${snapname}" | grep -q "^autozsys_"; then
            snapname=""
        fi
        # We store the release only if it different from main dataset release (snapshot before a release upgrade)
        releasename=$(get_field_from_entry "${entry}" 4)
        if [ "${releasename}" = "${main_dataset_releasename}" ]; then
            releasename=""
        fi
        # Snapshot date
        foo="$(get_field_from_entry "${entry}" 5)"
        snapdate="$(date -d @$(get_field_from_entry "${entry}" 5) "+%x @ %H:%M")"
        # For snapshots/clones the name can have the following formats:
        # 	<DATE>: autozsys, same release
        #   <OLD_RELEASE> on <DATE>: autozsys, different release
        #   <SNAPNAME> on <DATE>: Manual snapshot, same release
        #   <SNAPNAME>, <OLD_RELEASE> on <DATE>: Manual snapshot, different release
        if [ "${snapname}" = "" -a "${releasename}" = "" ]; then
            name="${snapdate}"
        elif [ "${snapname}" = "" -a "${releasename}" != "" ]; then
            name=$(gettext_printf "%s on %s" "${releasename}" "${snapdate}")
        elif [ "${snapname}" != "" -a "${releasename}" = "" ]; then
            name=$(gettext_printf "%s on %s" "${snapname}" "${snapdate}")
        else # snapname != "" && releasename != ""
            name=$(gettext_printf "%s, %s on %s" "${snapname}" "${releasename}" "${snapdate}")
        fi
        # Choose kernel and initrd if the snapshot was booted successfully on a specific kernel before
        # Take latest by default if no match
        initrd=$(get_field_from_entry "${entry}" 7 | cut -d'|' -f1)
        kernel=$(get_field_from_entry "${entry}" 8 | cut -d'|' -f1)
        last_used_kernel="$(get_field_from_entry "${entry}" 9)"
        # We must align initrds with kernels.
        # Adds initrds to the stack then pop them 1 by 1 as we process the kernels
        set -- $(get_field_from_entry "${entry}" 7 | tr "|" " ")
        for k in $(get_field_from_entry "${entry}" 8|tr "|" " "); do
            # get initrd and pop to the next one
            candidate_initrd="$1"; shift
            kernel_basename=$(basename "${k}")
            if [ "${kernel_basename}" = "${last_used_kernel}" ]; then
                kernel="${k}"
                initrd="${candidate_initrd}"
                break
            fi
        done
        echo "${entry}" | awk "BEGIN{ FS=\"\t\"; OFS=\"\t\"}    {print \$3, \$2, \"history\", \"$name\", \$1, \$6, \"$initrd\", \"$kernel\"}"
    done
}
# Generate metadata from a BOOTLIST that will subsequently used to generate
# the final grub menu entries
generate_grub_menu_metadata() {
    local bootlist="$1"
    # Sort machineids by last_used from their main entry
    for machineid in $(get_machines_sorted "${bootlist}"); do
        entries="$(sort_entries_for_machineid "${bootlist}" ${machineid})"
        main_entry="$(get_main_entry "${entries}")"
        if [ -z "$main_entry" ]; then
            continue
        fi
        main_entry_meta "${main_entry}"
        advanced_entries_meta "${main_entry}"
        main_dataset_name="$(get_field_from_entry "${main_entry}" 1)"
        main_dataset_releasename="$(get_field_from_entry "${main_entry}" 4)"
        # grep -v errcode != 0 if there is no match. || true to not fail with -e
        other_entries="$(echo "${entries}" | grep -v "${main_entry}" || true)"
        history_entries_meta "${other_entries}" "${main_dataset_name}" "${main_dataset_releasename}"
    done
}
# Print the configuration part common to all sections
# Note:
#   If 10_linux runs these part will be defined twice in grub configuration
print_menu_prologue() {
    cat << 'EOF'
function gfxmode {
	set gfxpayload="${1}"
EOF
    if [ "${vt_handoff}" = 1 ]; then
        cat << 'EOF'
	if [ "${1}" = "keep" ]; then
		set vt_handoff=vt.handoff=1
	else
		set vt_handoff=
	fi
EOF
    fi
    cat << EOF
}
EOF
    # Use ELILO's generic "efifb" when it's known to be available.
    # FIXME: We need an interface to select vesafb in case efifb can't be used.
    GRUB_GFXPAYLOAD_LINUX="${GRUB_GFXPAYLOAD_LINUX:-}"
    if [ "${GRUB_GFXPAYLOAD_LINUX}" != "" ] || [ "${gfxpayload_dynamic}" = 0 ]; then
        echo "set linux_gfx_mode=${GRUB_GFXPAYLOAD_LINUX}"
    else
        cat << EOF
if [ "\${recordfail}" != 1 ]; then
  if [ -e \${prefix}/gfxblacklist.txt ]; then
    if hwmatch \${prefix}/gfxblacklist.txt 3; then
      if [ \${match} = 0 ]; then
        set linux_gfx_mode=keep
      else
        set linux_gfx_mode=text
      fi
    else
      set linux_gfx_mode=text
    fi
  else
    set linux_gfx_mode=keep
  fi
else
  set linux_gfx_mode=text
fi
EOF
    fi
    cat << EOF
export linux_gfx_mode
EOF
}
# Cache for prepare_grub_to_access_device call
# $1: boot_device
# $2: submenu_level
prepare_grub_to_access_device_cached() {
    local boot_device="$1"
    local submenu_level="$2"
    local boot_device_idx="$(echo ${boot_device} | tr '/' '_')"
    cache_file="${ZFSTMP}/$(echo boot_device${boot_device_idx})"
    if [ ! -f "${cache_file}" ]; then
        set +u
        echo "$(prepare_grub_to_access_device "${boot_device}")" > "${cache_file}"
        set -u
        for i in 0 1 2; do
            submenu_indentation="$(printf %${i}s | tr " " "${grub_tab}")"
            sed "s/^/${submenu_indentation}	/" "${cache_file}" > "${cache_file}--${i}"
        done
    fi
    cat "${cache_file}--${submenu_level}"
}
# Print a grub menu entry
zfs_linux_entry () {
    submenu_level="$1"
    title="$2"
    type="$3"
    dataset="$4"
    boot_device="$5"
    initrd="$6"
    kernel="$7"
    kernel_version="$8"
    kernel_additional_args="${9:-}"
    boot_devices="${10:-}"
    submenu_indentation="$(printf %${submenu_level}s | tr " " "${grub_tab}")"
    echo "${submenu_indentation}menuentry '$(echo "${title}" | grub_quote)' ${CLASS} \${menuentry_id_option} 'gnulinux-${dataset}-${kernel_version}' {"
    if [ "${quick_boot}" = 1 ]; then
        echo "${submenu_indentation}	recordfail"
    fi
    if [ "${type}" != "recovery" ] ; then
        GRUB_SAVEDEFAULT=${GRUB_SAVEDEFAULT:-}
        default_entry="$(save_default_entry)"
        if [ -n "${default_entry}" ]; then
            echo "${submenu_indentation}	${default_entry}"
        fi
    fi
    # Use ELILO's generic "efifb" when it's known to be available.
    # FIXME: We need an interface to select vesafb in case efifb can't be used.
    if [ "${GRUB_GFXPAYLOAD_LINUX}" = "" ]; then
        echo "${submenu_indentation}	load_video"
    else
        if [ "${GRUB_GFXPAYLOAD_LINUX}" != "text" ]; then
            echo "${submenu_indentation}	load_video"
        fi
    fi
    if ([ "${ubuntu_recovery}" = 0 ] || [ "${type}" != "recovery" ]) && \
        ([ "${GRUB_GFXPAYLOAD_LINUX}" != "" ] || [ "${gfxpayload_dynamic}" = 1 ]); then
        echo "${submenu_indentation}	gfxmode \${linux_gfx_mode}"
    fi
    echo "${submenu_indentation}	insmod gzio"
    echo "${submenu_indentation}	if [ \"\${grub_platform}\" = xen ]; then insmod xzio; insmod lzopio; fi"
    if [ -n "$boot_devices" ]; then
        for device in ${boot_devices}; do
            echo "${submenu_indentation}	if [ "${boot_device}" = "${device}" ]; then"
            echo "$(prepare_grub_to_access_device_cached "${device}" $(( submenu_level +1 )) )"
            echo "${submenu_indentation}	fi"
        done
    else
        echo "$(prepare_grub_to_access_device_cached "${boot_device}" "${submenu_level}")"
    fi
    if [ "${quiet_boot}" = 0 ] || [ "${type}" != simple ]; then
        echo "${submenu_indentation}	echo $(gettext_printf "Loading Linux %s ..." ${kernel_version} | grub_quote)"
    fi
    linux_default_args="${GRUB_CMDLINE_LINUX} ${GRUB_CMDLINE_LINUX_DEFAULT}"
    if [ ${type} = "recovery" ]; then
        linux_default_args="${GRUB_CMDLINE_LINUX_RECOVERY} ${GRUB_CMDLINE_LINUX}"
    fi
    echo "${submenu_indentation}	linux	${kernel} root=ZFS=${dataset} ro ${linux_default_args} ${kernel_additional_args}"
    if [ "${quiet_boot}" = 0 ] || [ "${type}" != simple ]; then
        echo "${submenu_indentation}	echo '$(gettext_printf "Loading initial ramdisk ..." | grub_quote)'"
    fi
    echo "${submenu_indentation}	initrd	${initrd}"
    echo "${submenu_indentation}}"
}
# Generate a GRUB Menu from menu meta data
# $1 menu metadata
generate_grub_menu() {
    local menu_metadata="$1"
    local last_section=""
    local main_dataset_name=""
    local main_dataset=""
    local have_zsys=""
    if [ -z "${menu_metadata}" ]; then
        return
    fi
    CLASS="--class gnu-linux --class gnu --class os"
    if [ "${GRUB_DISTRIBUTOR}" = "" ] ; then
        OS=GNU/Linux
    else
        case ${GRUB_DISTRIBUTOR} in
            Ubuntu|Kubuntu)
            OS="${GRUB_DISTRIBUTOR}"
            ;;
            *)
            OS="${GRUB_DISTRIBUTOR} GNU/Linux"
            ;;
        esac
        CLASS="--class $(echo ${GRUB_DISTRIBUTOR} | tr 'A-Z' 'a-z' | cut -d' ' -f1 | LC_ALL=C sed 's,[^[:alnum:]_],_,g') ${CLASS}"
    fi
    if [ -x /lib/recovery-mode/recovery-menu ]; then
        GRUB_CMDLINE_LINUX_RECOVERY=recovery
    else
        GRUB_CMDLINE_LINUX_RECOVERY=single
    fi
    if [ "${ubuntu_recovery}" = 1 ]; then
        GRUB_CMDLINE_LINUX_RECOVERY="${GRUB_CMDLINE_LINUX_RECOVERY} nomodeset"
    fi
    case "$GENKERNEL_ARCH" in
        x86*) GRUB_CMDLINE_LINUX_RECOVERY="$GRUB_CMDLINE_LINUX_RECOVERY dis_ucode_ldr";;
    esac
    if [ "${vt_handoff}" = 1 ]; then
        for word in ${GRUB_CMDLINE_LINUX_DEFAULT}; do
            if [ "${word}" = splash ]; then
                GRUB_CMDLINE_LINUX_DEFAULT="${GRUB_CMDLINE_LINUX_DEFAULT} \${vt_handoff}"
            fi
        done
    fi
    print_menu_prologue
    cat<<'EOF'
function zsyshistorymenu {
	# $1: root dataset (eg rpool/ROOT/ubuntu_2zhm07@autozsys_k56fr6)
	# $2: boot device id (eg 411f29ce1557bfed)
	# $3: initrd (eg /BOOT/ubuntu_2zhm07@autozsys_k56fr6/initrd.img-5.4.0-21-generic)
	# $4: kernel (eg /BOOT/ubuntu_2zhm07@autozsys_k56fr6/vmlinuz-5.4.0-21-generic)
	# $5: kernel_version (eg 5.4.0-21-generic)
	set root_dataset="${1}"
	set boot_device="${2}"
	set initrd="${3}"
	set kernel="${4}"
	set kversion="${5}"
EOF
    boot_devices=$(echo "${menu_metadata}" | cut -d"$(printf '\t')" -f6 | sort -u)
    title=$(gettext_printf "Revert system only")
    zfs_linux_entry 1 "${title}" "simple" '${root_dataset}' '${boot_device}' '${initrd}' '${kernel}' '${kversion}' '' "${boot_devices}"
    title="$(gettext_printf "Revert system and user data")"
    zfs_linux_entry 1 "${title}" "simple" '${root_dataset}' '${boot_device}' '${initrd}' '${kernel}' '${kversion}' 'zsys-revert=userdata' "${boot_devices}"
    GRUB_DISABLE_RECOVERY="${GRUB_DISABLE_RECOVERY:-}"
    if [ "${GRUB_DISABLE_RECOVERY}" != "true" ]; then
        title="$(gettext_printf "Revert system only (%s)" "$(gettext "${GRUB_RECOVERY_TITLE}")")"
        zfs_linux_entry 1 "${title}" "recovery" '${root_dataset}' '${boot_device}' '${initrd}' '${kernel}' '${kversion}' '' "${boot_devices}"
        title="$(gettext_printf "Revert system and user data (%s)" "$(gettext "${GRUB_RECOVERY_TITLE}")")"
        zfs_linux_entry 1 "${title}" "recovery" '${root_dataset}' '${boot_device}' '${initrd}' '${kernel}' '${kversion}' 'zsys-revert=userdata' "${boot_devices}"
    fi
echo "}"
echo
    # IFS is set to TAB (ASCII 0x09)
    echo "${menu_metadata}" |
    {
        at_least_one_entry=0
        have_zsys="$(which zsysd || true)"
        while IFS="$(printf '\t')" read -r machineid iszsys section name dataset device initrd kernel opt; do
            # Disable history for non zsys system or if systems is a zsys one and zsys isn't installed.
            # In pure zfs systems, we identified multiple issues due to the mount generator
            # in upstream zfs which makes it incompatible. Don't show history for now.
            if [ "${section}" = "history" ]; then
                if [ "${iszsys}" != "yes" ] || [ "${iszsys}" = "yes" -a -z "${have_zsys}" ]; then
                    continue
                fi
            fi
            if [ "${last_section}" != "${section}" -a -n "${last_section}" ]; then
                # Close previous section wrapper
                if [ "${last_section}" != "main" ]; then
                    echo "}"    # Add grub_tabs
                    at_least_one_entry=0
                fi
            fi
            case "${section}" in
                main)
                    title="${name}"
                    main_dataset_name="${name}"
                    main_dataset="${dataset}"
                    kernel_version=$(basename "${kernel}" | sed -e "s,^[^0-9]*-,,g")
                    zfs_linux_entry 0 "${title}" "simple" "${dataset}" "${device}" "${initrd}" "${kernel}" "${kernel_version}"
                    at_least_one_entry=1
                ;;
                advanced)
                    # normal and recovery entries for a given kernel
                    if [ "${last_section}" != "${section}" ]; then
                        echo "submenu '$(gettext_printf "Advanced options for %s" "${main_dataset_name}" | grub_quote)' \${menuentry_id_option} 'gnulinux-advanced-${main_dataset}' {"
                    fi
                    last_booted_kernel_marker=""
                    if [ "${opt}" = "true" ]; then
                        last_booted_kernel_marker="* "
                    fi
                    kernel_version=$(basename "${kernel}" | sed -e "s,^[^0-9]*-,,g")
                    title="$(gettext_printf "%s%s, with Linux %s" "${last_booted_kernel_marker}" "${name}" "${kernel_version}")"
                    zfs_linux_entry 1 "${title}" "advanced" "${dataset}" "${device}" "${initrd}" "${kernel}" "${kernel_version}"
                    GRUB_DISABLE_RECOVERY=${GRUB_DISABLE_RECOVERY:-}
                    if [ "${GRUB_DISABLE_RECOVERY}" != "true" ]; then
                        title="$(gettext_printf "%s%s, with Linux %s (%s)" "${last_booted_kernel_marker}" "${name}" "${kernel_version}" "$(gettext "${GRUB_RECOVERY_TITLE}")")"
                        zfs_linux_entry 1 "${title}" "recovery" "${dataset}" "${device}" "${initrd}" "${kernel}" "${kernel_version}"
                    fi
                    at_least_one_entry=1
                ;;
                history)
                    # Revert to a snapshot
                    # revert system, revert system and user data and associated recovery entries
                    if [ "${last_section}" != "${section}" ]; then
                        echo "submenu '$(gettext_printf "History for %s" "${main_dataset_name}" | grub_quote)' \${menuentry_id_option} 'gnulinux-history-${main_dataset}' {"
                    fi
                    if [ "${iszsys}" = "yes" ]; then
                        title="$(gettext_printf "Revert to %s" "${name}" | grub_quote)"
                    else
                        title="$(gettext_printf "Boot on %s" "${name}" | grub_quote)"
                    fi
                    echo "	submenu '${title}' \${menuentry_id_option} 'gnulinux-history-${dataset}' {"
                    kernel_version=$(basename "${kernel}" | sed -e "s,^[^0-9]*-,,g")
                    # Zsys only: let revert system without destroying snapshots
                    if [ "${iszsys}" = "yes" ]; then
                        echo "${grub_tab}${grub_tab}zsyshistorymenu" \"${dataset}\" \"${device}\" \"${initrd}\" \"${kernel}\" \"${kernel_version}\"
                    # Non-zsys: boot temporarly on snapshots or rollback (destroying intermediate snapshots)
                    else
                        title="$(gettext_printf "One time boot")"
                        zfs_linux_entry 2 "${title}" "simple" "${dataset}" "${device}" "${initrd}" "${kernel}" "${kernel_version}"
                        GRUB_DISABLE_RECOVERY="${GRUB_DISABLE_RECOVERY:-}"
                        if [ "${GRUB_DISABLE_RECOVERY}" != "true" ]; then
                            title="$(gettext_printf "One time boot (%s)" "$(gettext "${GRUB_RECOVERY_TITLE}")")"
                            zfs_linux_entry 2 "${title}" "recovery" "${dataset}" "${device}" "${initrd}" "${kernel}" "${kernel_version}"
                        fi
                        title="$(gettext_printf "Revert system (all intermediate snapshots will be destroyed)")"
                        zfs_linux_entry 2 "${title}" "simple" "${dataset}" "${device}" "${initrd}" "${kernel}" "${kernel_version}" "rollback=yes"
                    fi
                    echo "	}"
                    at_least_one_entry=1
                ;;
                *)
                    grub_warn "unknown section: ${section}. Ignoring entry ${name} for ${dataset}"
                ;;
            esac
            last_section="${section}"
        done
        if [ "${at_least_one_entry}" -eq 1 ]; then
            echo "}"
        fi
    }
}
# don't add trailing newline of variable is empty
# $1: content to write
# $2: destination file
trailing_newline_if_not_empty() {
    content="$1"
    dest="$2"
    if [ -z "${content}" ]; then
        rm -f "${dest}"
        touch "${dest}"
        return
    fi
    echo "${content}" > "${dest}"
}
GRUB_LINUX_ZFS_TEST="${GRUB_LINUX_ZFS_TEST:-}"
case "${GRUB_LINUX_ZFS_TEST}" in
    bootlist)
        # Import all available pools on the system and return imported list
        imported_pools=$(import_pools)
        boot_list="$(bootlist ${MNTDIR})"
        trailing_newline_if_not_empty "${boot_list}" "${GRUB_LINUX_ZFS_TEST_OUTPUT}"
        break
    ;;
    metamenu)
        boot_list="$(cat ${GRUB_LINUX_ZFS_TEST_INPUT})"
        menu_metadata="$(generate_grub_menu_metadata "${boot_list}")"
        trailing_newline_if_not_empty "${menu_metadata}" "${GRUB_LINUX_ZFS_TEST_OUTPUT}"
        break
    ;;
    grubmenu)
        menu_metadata="$(cat ${GRUB_LINUX_ZFS_TEST_INPUT})"
        grub_menu=$(generate_grub_menu "${menu_metadata}")
        trailing_newline_if_not_empty "${grub_menu}" "${GRUB_LINUX_ZFS_TEST_OUTPUT}"
        break
    ;;
    *)
        # Import all available pools on the system and return imported list
        imported_pools=$(import_pools)
        # Generate the complete list of boot entries
        boot_list="$(bootlist ${MNTDIR})"
        # Create boot menu meta data from the list of boot entries
        menu_metadata="$(generate_grub_menu_metadata "${boot_list}")"
        # Create boot menu meta data from the list of boot entries
        grub_menu="$(generate_grub_menu "${menu_metadata}")"
        if [ -n "${grub_menu}" ]; then
            # We want the trailing newline as a marker will be added
            echo "${grub_menu}"
        fi
    ;;
esac

========================= sda8/etc/grub.d/34_linux_xen =========================

#! /bin/sh
set -e
# grub-mkconfig helper script.
# Copyright (C) 2006,2007,2008,2009,2010  Free Software Foundation, Inc.
#
# GRUB is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# GRUB is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
prefix="/usr"
exec_prefix="/usr"
datarootdir="/usr/share"
. "$pkgdatadir/grub-mkconfig_lib"
export TEXTDOMAIN=grub
export TEXTDOMAINDIR="${datarootdir}/locale"
CLASS="--class gnu-linux --class gnu --class os --class xen"
SUPPORTED_INITS="sysvinit:/lib/sysvinit/init systemd:/lib/systemd/systemd upstart:/sbin/upstart"
if [ "x${GRUB_DISTRIBUTOR}" = "x" ] ; then
  OS=GNU/Linux
else
  OS="${GRUB_DISTRIBUTOR} GNU/Linux"
  CLASS="--class $(echo ${GRUB_DISTRIBUTOR} | tr 'A-Z' 'a-z' | cut -d' ' -f1|LC_ALL=C sed 's,[^[:alnum:]_],_,g') ${CLASS}"
fi
# loop-AES arranges things so that /dev/loop/X can be our root device, but
# the initrds that Linux uses don't like that.
case ${GRUB_DEVICE} in
  /dev/loop/*|/dev/loop[0-9])
    GRUB_DEVICE=`losetup ${GRUB_DEVICE} | sed -e "s/^[^(]*(\([^)]\+\)).*/\1/"`
    # We can't cope with devices loop-mounted from files here.
    case ${GRUB_DEVICE} in
      /dev/*) ;;
      *) exit 0 ;;
    esac
  ;;
esac
# Default to disabling partition uuid support to maintian compatibility with
# older kernels.
GRUB_DISABLE_LINUX_PARTUUID=${GRUB_DISABLE_LINUX_PARTUUID-true}
# btrfs may reside on multiple devices. We cannot pass them as value of root= parameter
# and mounting btrfs requires user space scanning, so force UUID in this case.
if ( [ "x${GRUB_DEVICE_UUID}" = "x" ] && [ "x${GRUB_DEVICE_PARTUUID}" = "x" ] ) \
    || ( [ "x${GRUB_DISABLE_LINUX_UUID}" = "xtrue" ] \
	&& [ "x${GRUB_DISABLE_LINUX_PARTUUID}" = "xtrue" ] ) \
    || ( ! test -e "/dev/disk/by-uuid/${GRUB_DEVICE_UUID}" \
	&& ! test -e "/dev/disk/by-partuuid/${GRUB_DEVICE_PARTUUID}" ) \
    || ( test -e "${GRUB_DEVICE}" && uses_abstraction "${GRUB_DEVICE}" lvm ); then
  LINUX_ROOT_DEVICE=${GRUB_DEVICE}
elif [ "x${GRUB_DEVICE_UUID}" = "x" ] \
    || [ "x${GRUB_DISABLE_LINUX_UUID}" = "xtrue" ]; then
  LINUX_ROOT_DEVICE=PARTUUID=${GRUB_DEVICE_PARTUUID}
else
  LINUX_ROOT_DEVICE=UUID=${GRUB_DEVICE_UUID}
fi
# Allow overriding GRUB_CMDLINE_LINUX and GRUB_CMDLINE_LINUX_DEFAULT.
if [ "${GRUB_CMDLINE_LINUX_XEN_REPLACE}" ]; then
  GRUB_CMDLINE_LINUX="${GRUB_CMDLINE_LINUX_XEN_REPLACE}"
fi
if [ "${GRUB_CMDLINE_LINUX_XEN_REPLACE_DEFAULT}" ]; then
  GRUB_CMDLINE_LINUX_DEFAULT="${GRUB_CMDLINE_LINUX_XEN_REPLACE_DEFAULT}"
fi
case x"$GRUB_FS" in
    xbtrfs)
	rootsubvol="`make_system_path_relative_to_its_root /`"
	rootsubvol="${rootsubvol#/}"
	if [ "x${rootsubvol}" != x ]; then
	    GRUB_CMDLINE_LINUX="rootflags=subvol=${rootsubvol} ${GRUB_CMDLINE_LINUX}"
	fi;;
    xzfs)
	rpool=`${grub_probe} --device ${GRUB_DEVICE} --target=fs_label 2>/dev/null || true`
	bootfs="`make_system_path_relative_to_its_root / | sed -e "s,@$,,"`"
	LINUX_ROOT_DEVICE="ZFS=${rpool}${bootfs%/}"
	;;
esac
title_correction_code=
linux_entry ()
{
  os="$1"
  version="$2"
  xen_version="$3"
  type="$4"
  args="$5"
  xen_args="$6"
  if [ -z "$boot_device_id" ]; then
      boot_device_id="$(grub_get_device_id "${GRUB_DEVICE}")"
  fi
  if [ x$type != xsimple ] ; then
      if [ x$type = xrecovery ] ; then
	  title="$(gettext_printf "%s, with Xen %s and Linux %s (%s)" "${os}" "${xen_version}" "${version}" "$(gettext "${GRUB_RECOVERY_TITLE}")")"
      elif [ "${type#init-}" != "$type" ] ; then
	  title="$(gettext_printf "%s, with Xen %s and Linux %s (%s)" "${os}" "${xen_version}" "${version}" "${type#init-}")"
      else
	  title="$(gettext_printf "%s, with Xen %s and Linux %s" "${os}" "${xen_version}" "${version}")"
      fi
      replacement_title="$(echo "Advanced options for ${OS}" | sed 's,>,>>,g')>$(echo "$title" | sed 's,>,>>,g')"
      if [ x"Xen ${xen_version}>$title" = x"$GRUB_ACTUAL_DEFAULT" ]; then
         quoted="$(echo "$GRUB_ACTUAL_DEFAULT" | grub_quote)"
         title_correction_code="${title_correction_code}if [ \"x\$default\" = '$quoted' ]; then default='$(echo "$replacement_title" | grub_quote)'; fi;"
         grub_warn "$(gettext_printf "Please don't use old title \`%s' for GRUB_DEFAULT, use \`%s' (for versions before 2.00) or \`%s' (for 2.00 or later)" "$GRUB_ACTUAL_DEFAULT" "$replacement_title" "gnulinux-advanced-$boot_device_id>gnulinux-$version-$type-$boot_device_id")"
      fi
      echo "menuentry '$(echo "$title" | grub_quote)' ${CLASS} \$menuentry_id_option 'xen-gnulinux-$version-$type-$boot_device_id' {" | sed "s/^/$submenu_indentation/"
  else
      title="$(gettext_printf "%s, with Xen hypervisor" "${os}")"
      echo "menuentry '$(echo "$title" | grub_quote)' ${CLASS} \$menuentry_id_option 'xen-gnulinux-simple-$boot_device_id' {" | sed "s/^/$submenu_indentation/"
  fi
  if [ x$type != xrecovery ] ; then
      save_default_entry | grub_add_tab | sed "s/^/$submenu_indentation/"
  fi
  if [ -z "${prepare_boot_cache}" ]; then
    prepare_boot_cache="$(prepare_grub_to_access_device ${GRUB_DEVICE_BOOT} | grub_add_tab)"
  fi
  printf '%s\n' "${prepare_boot_cache}" | sed "s/^/$submenu_indentation/"
  xmessage="$(gettext_printf "Loading Xen %s ..." ${xen_version})"
  lmessage="$(gettext_printf "Loading Linux %s ..." ${version})"
  sed "s/^/$submenu_indentation/" << EOF
	echo	'$(echo "$xmessage" | grub_quote)'
        if [ "\$grub_platform" = "pc" -o "\$grub_platform" = "" ]; then
            xen_rm_opts=
        else
            xen_rm_opts="no-real-mode edd=off"
        fi
	${xen_loader}	${rel_xen_dirname}/${xen_basename} placeholder ${xen_args} \${xen_rm_opts}
	echo	'$(echo "$lmessage" | grub_quote)'
	${module_loader}	${rel_dirname}/${basename} placeholder root=${linux_root_device_thisversion} ro ${args}
EOF
  if test -n "${initrd}" ; then
    # TRANSLATORS: ramdisk isn't identifier. Should be translated.
    message="$(gettext_printf "Loading initial ramdisk ...")"
    initrd_path=
    for i in ${initrd}; do
       initrd_path="${initrd_path} ${rel_dirname}/${i}"
    done
    sed "s/^/$submenu_indentation/" << EOF
	echo	'$(echo "$message" | grub_quote)'
	${module_loader}	--nounzip   $(echo $initrd_path)
EOF
  fi
  sed "s/^/$submenu_indentation/" << EOF
}
EOF
}
linux_list=
for i in /boot/vmlinu[xz]-* /vmlinu[xz]-* /boot/kernel-*; do
    if grub_file_is_not_garbage "$i"; then
    	basename=$(basename $i)
	version=$(echo $basename | sed -e "s,^[^0-9]*-,,g")
	dirname=$(dirname $i)
	config=
	for j in "${dirname}/config-${version}" "${dirname}/config-${alt_version}" "/etc/kernels/kernel-config-${version}" ; do
	    if test -e "${j}" ; then
		config="${j}"
		break
	    fi
	done
        if (grep -qx "CONFIG_XEN_DOM0=y" "${config}" 2> /dev/null || grep -qx "CONFIG_XEN_PRIVILEGED_GUEST=y" "${config}" 2> /dev/null); then linux_list="$linux_list $i" ; fi
    fi
done
if [ "x${linux_list}" = "x" ] ; then
    exit 0
fi
file_is_not_sym () {
    case "$1" in
	*/xen-syms-*)
	    return 1;;
	*)
	    return 0;;
    esac
}
xen_list=
for i in /boot/xen*; do
    if grub_file_is_not_garbage "$i" && file_is_not_sym "$i" ; then xen_list="$xen_list $i" ; fi
done
prepare_boot_cache=
boot_device_id=
title_correction_code=
machine=`uname -m`
case "$machine" in
    i?86) GENKERNEL_ARCH="x86" ;;
    mips|mips64) GENKERNEL_ARCH="mips" ;;
    mipsel|mips64el) GENKERNEL_ARCH="mipsel" ;;
    arm*) GENKERNEL_ARCH="arm" ;;
    *) GENKERNEL_ARCH="$machine" ;;
esac
# Extra indentation to add to menu entries in a submenu. We're not in a submenu
# yet, so it's empty. In a submenu it will be equal to '\t' (one tab).
submenu_indentation=""
is_top_level=true
while [ "x${xen_list}" != "x" ] ; do
    list="${linux_list}"
    current_xen=`version_find_latest $xen_list`
    xen_basename=`basename ${current_xen}`
    xen_dirname=`dirname ${current_xen}`
    rel_xen_dirname=`make_system_path_relative_to_its_root $xen_dirname`
    xen_version=`echo $xen_basename | sed -e "s,.gz$,,g;s,^xen-,,g"`
    if [ -z "$boot_device_id" ]; then
	boot_device_id="$(grub_get_device_id "${GRUB_DEVICE}")"
    fi
    if [ "x$is_top_level" != xtrue ]; then
	echo "	submenu '$(gettext_printf "Xen hypervisor, version %s" "${xen_version}" | grub_quote)' \$menuentry_id_option 'xen-hypervisor-$xen_version-$boot_device_id' {"
    fi
    if ($grub_file --is-arm64-efi $current_xen); then
	xen_loader="xen_hypervisor"
	module_loader="xen_module"
    else
	if ($grub_file --is-x86-multiboot2 $current_xen); then
	    xen_loader="multiboot2"
	    module_loader="module2"
	else
	    xen_loader="multiboot"
	    module_loader="module"
        fi
    fi
    initrd_early=
    for i in ${GRUB_EARLY_INITRD_LINUX_STOCK} \
             ${GRUB_EARLY_INITRD_LINUX_CUSTOM}; do
       if test -e "${xen_dirname}/${i}" ; then
          initrd_early="${initrd_early} ${i}"
       fi
    done
    while [ "x$list" != "x" ] ; do
	linux=`version_find_latest $list`
	gettext_printf "Found linux image: %s\n" "$linux" >&2
	basename=`basename $linux`
	dirname=`dirname $linux`
	rel_dirname=`make_system_path_relative_to_its_root $dirname`
	version=`echo $basename | sed -e "s,^[^0-9]*-,,g"`
	alt_version=`echo $version | sed -e "s,\.old$,,g"`
	linux_root_device_thisversion="${LINUX_ROOT_DEVICE}"
	initrd_real=
	for i in "initrd.img-${version}" "initrd-${version}.img" "initrd-${version}.gz" \
	   "initrd-${version}" "initramfs-${version}.img" \
	   "initrd.img-${alt_version}" "initrd-${alt_version}.img" \
	   "initrd-${alt_version}" "initramfs-${alt_version}.img" \
	   "initramfs-genkernel-${version}" \
	   "initramfs-genkernel-${alt_version}" \
	   "initramfs-genkernel-${GENKERNEL_ARCH}-${version}" \
	   "initramfs-genkernel-${GENKERNEL_ARCH}-${alt_version}" ; do
	    if test -e "${dirname}/${i}" ; then
		initrd_real="$i"
		break
	    fi
	done
	initrd=
	if test -n "${initrd_early}" || test -n "${initrd_real}"; then
	    initrd="${initrd_early} ${initrd_real}"
	    initrd_display=
	    for i in ${initrd}; do
		initrd_display="${initrd_display} ${dirname}/${i}"
	    done
	    gettext_printf "Found initrd image: %s\n" "$(echo $initrd_display)" >&2
	fi
	if test -z "${initrd_real}"; then
    # "UUID=" magic is parsed by initrds.  Since there's no initrd, it can't work here.
	    if [ "x${GRUB_DEVICE_PARTUUID}" = "x" ] \
		|| [ "x${GRUB_DISABLE_LINUX_PARTUUID}" = "xtrue" ]; then
		linux_root_device_thisversion=${GRUB_DEVICE}
	    else
		linux_root_device_thisversion=PARTUUID=${GRUB_DEVICE_PARTUUID}
	    fi
	fi
	if [ "x$is_top_level" = xtrue ] && [ "x${GRUB_DISABLE_SUBMENU}" != xy ]; then
	    linux_entry "${OS}" "${version}" "${xen_version}" simple \
		"${GRUB_CMDLINE_LINUX} ${GRUB_CMDLINE_LINUX_DEFAULT}" "${GRUB_CMDLINE_XEN} ${GRUB_CMDLINE_XEN_DEFAULT}"
	    submenu_indentation="$grub_tab$grub_tab"
    
	    if [ -z "$boot_device_id" ]; then
		boot_device_id="$(grub_get_device_id "${GRUB_DEVICE}")"
	    fi
            # TRANSLATORS: %s is replaced with an OS name
	    echo "submenu '$(gettext_printf "Advanced options for %s (with Xen hypervisor)" "${OS}" | grub_quote)' \$menuentry_id_option 'gnulinux-advanced-$boot_device_id' {"
	echo "	submenu '$(gettext_printf "Xen hypervisor, version %s" "${xen_version}" | grub_quote)' \$menuentry_id_option 'xen-hypervisor-$xen_version-$boot_device_id' {"
	   is_top_level=false
	fi
	linux_entry "${OS}" "${version}" "${xen_version}" advanced \
	    "${GRUB_CMDLINE_LINUX} ${GRUB_CMDLINE_LINUX_DEFAULT}" "${GRUB_CMDLINE_XEN} ${GRUB_CMDLINE_XEN_DEFAULT}"
	for supported_init in ${SUPPORTED_INITS}; do
	    init_path="${supported_init#*:}"
	    if [ -x "${init_path}" ] && [ "$(readlink -f /sbin/init)" != "$(readlink -f "${init_path}")" ]; then
		linux_entry "${OS}" "${version}" "${xen_version}" "init-${supported_init%%:*}" \
		    "${GRUB_CMDLINE_LINUX} ${GRUB_CMDLINE_LINUX_DEFAULT} init=${init_path}" "${GRUB_CMDLINE_XEN} ${GRUB_CMDLINE_XEN_DEFAULT}"
	    fi
	done
	if [ "x${GRUB_DISABLE_RECOVERY}" != "xtrue" ]; then
	    linux_entry "${OS}" "${version}" "${xen_version}" recovery \
		"single ${GRUB_CMDLINE_LINUX}" "${GRUB_CMDLINE_XEN}"
	fi
	list=`echo $list | tr ' ' '\n' | fgrep -vx "$linux" | tr '\n' ' '`
    done
    if [ x"$is_top_level" != xtrue ]; then
	echo '	}'
    fi
    xen_list=`echo $xen_list | tr ' ' '\n' | fgrep -vx "$current_xen" | tr '\n' ' '`
done
# If at least one kernel was found, then we need to
# add a closing '}' for the submenu command.
if [ x"$is_top_level" != xtrue ]; then
  echo '}'
fi
echo "$title_correction_code"

========================= sda8/etc/grub.d/36_os-prober =========================

#! /bin/sh
set -e
# grub-mkconfig helper script.
# Copyright (C) 2006,2007,2008,2009  Free Software Foundation, Inc.
#
# GRUB is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# GRUB is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
prefix="/usr"
exec_prefix="/usr"
datarootdir="/usr/share"
quick_boot="1"
export TEXTDOMAIN=grub
export TEXTDOMAINDIR="${datarootdir}/locale"
. "$pkgdatadir/grub-mkconfig_lib"
found_other_os=
adjust_timeout () {
  if [ "$quick_boot" = 1 ] && [ "x${found_other_os}" != "x" ]; then
    cat << EOF
set timeout_style=menu
if [ "\${timeout}" = 0 ]; then
  set timeout=10
fi
EOF
  fi
}
if [ "x${GRUB_DISABLE_OS_PROBER}" = "xtrue" ]; then
  exit 0
fi
if [ -z "`which os-prober 2> /dev/null`" ] || [ -z "`which linux-boot-prober 2> /dev/null`" ] ; then
  # missing os-prober and/or linux-boot-prober
  exit 0
fi
OSPROBED="`os-prober | tr ' ' '^' | paste -s -d ' '`"
if [ -z "${OSPROBED}" ] ; then
  # empty os-prober output, nothing doing
  exit 0
fi
osx_entry() {
    found_other_os=1
    if [ x$2 = x32 ]; then
        # TRANSLATORS: it refers to kernel architecture (32-bit)
	bitstr="$(gettext "(32-bit)")"
    else
        # TRANSLATORS: it refers to kernel architecture (64-bit)
	bitstr="$(gettext "(64-bit)")"
    fi
    # TRANSLATORS: it refers on the OS residing on device %s
    onstr="$(gettext_printf "(on %s)" "${DEVICE}")"
        cat << EOF
menuentry '$(echo "${LONGNAME} $bitstr $onstr" | grub_quote)' --class osx --class darwin --class os \$menuentry_id_option 'osprober-xnu-$2-$(grub_get_device_id "${DEVICE}")'  {
EOF
	save_default_entry | grub_add_tab
	prepare_grub_to_access_device ${DEVICE} | grub_add_tab
	cat << EOF
        load_video
        set do_resume=0
        if [ /var/vm/sleepimage -nt10 / ]; then
           if xnu_resume /var/vm/sleepimage; then
             set do_resume=1
           fi
        fi
        if [ \$do_resume = 0 ]; then
           xnu_uuid ${OSXUUID} uuid
           if [ -f /Extra/DSDT.aml ]; then
              acpi -e /Extra/DSDT.aml
           fi
           if [ /kernelcache -nt /System/Library/Extensions ]; then
              $1 /kernelcache boot-uuid=\${uuid} rd=*uuid
           elif [ -f /System/Library/Kernels/kernel ]; then
              $1 /System/Library/Kernels/kernel boot-uuid=\${uuid} rd=*uuid
              xnu_kextdir /System/Library/Extensions
           else
              $1 /mach_kernel boot-uuid=\${uuid} rd=*uuid
              if [ /System/Library/Extensions.mkext -nt /System/Library/Extensions ]; then
                xnu_mkext /System/Library/Extensions.mkext
              else
                xnu_kextdir /System/Library/Extensions
              fi
           fi
           if [ -f /Extra/Extensions.mkext ]; then
              xnu_mkext /Extra/Extensions.mkext
           fi
           if [ -d /Extra/Extensions ]; then
              xnu_kextdir /Extra/Extensions
           fi
           if [ -f /Extra/devprop.bin ]; then
              xnu_devprop_load /Extra/devprop.bin
           fi
           if [ -f /Extra/splash.jpg ]; then
              insmod jpeg
              xnu_splash /Extra/splash.jpg
           fi
           if [ -f /Extra/splash.png ]; then
              insmod png
              xnu_splash /Extra/splash.png
           fi
           if [ -f /Extra/splash.tga ]; then
              insmod tga
              xnu_splash /Extra/splash.tga
           fi
        fi
}
EOF
}
used_osprober_linux_ids=
wubi=
for OS in ${OSPROBED} ; do
  DEVICE="`echo ${OS} | cut -d ':' -f 1`"
  LONGNAME="`echo ${OS} | cut -d ':' -f 2 | tr '^' ' '`"
  LABEL="`echo ${OS} | cut -d ':' -f 3 | tr '^' ' '`"
  BOOT="`echo ${OS} | cut -d ':' -f 4`"
  if UUID="`${grub_probe} --target=fs_uuid --device ${DEVICE%@*}`"; then
    EXPUUID="$UUID"
    if [ x"${DEVICE#*@}" != x ] ; then
      EXPUUID="${EXPUUID}@${DEVICE#*@}"
    fi
    if [ "x${GRUB_OS_PROBER_SKIP_LIST}" != "x" ] && [ "x`echo ${GRUB_OS_PROBER_SKIP_LIST} | grep -i -e '\b'${EXPUUID}'\b'`" != "x" ] ; then
      echo "Skipped ${LONGNAME} on ${DEVICE} by user request." >&2
      continue
    fi
  fi
  BTRFS="`echo ${OS} | cut -d ':' -f 5`"
  if [ "x$BTRFS" = "xbtrfs" ]; then
	BTRFSuuid="`echo ${OS} | cut -d ':' -f 6`"
	BTRFSsubvol="`echo ${OS} | cut -d ':' -f 7`"
  fi
  if [ -z "${LONGNAME}" ] ; then
    LONGNAME="${LABEL}"
  fi
  # os-prober returns text string followed by optional counter
  CLASS="--class $(echo "${LABEL}" | LC_ALL=C sed 's,[[:digit:]]*$,,' | cut -d' ' -f1 | tr 'A-Z' 'a-z' | LC_ALL=C sed 's,[^[:alnum:]_],_,g')"
  gettext_printf "Found %s on %s\n" "${LONGNAME}" "${DEVICE}" >&2
  case ${BOOT} in
    chain)
      case ${LONGNAME} in
	Windows*)
	  if [ -z "$wubi" ]; then
	    if [ -x /usr/share/lupin-support/grub-mkimage ] && \
	       /usr/share/lupin-support/grub-mkimage --test; then
	      wubi=yes
	    else
	      wubi=no
	    fi
	  fi
	  if [ "$wubi" = yes ]; then
	    echo "Skipping ${LONGNAME} on Wubi system" >&2
	    continue
	  fi
	  ;;
      esac
      found_other_os=1
	  onstr="$(gettext_printf "(on %s)" "${DEVICE}")"
      cat << EOF
menuentry '$(echo "${LONGNAME} $onstr" | grub_quote)' $CLASS --class os \$menuentry_id_option 'osprober-chain-$(grub_get_device_id "${DEVICE}")' {
EOF
      save_default_entry | grub_add_tab
      prepare_grub_to_access_device ${DEVICE} | grub_add_tab
      if [ x"`${grub_probe} --device ${DEVICE} --target=partmap`" = xmsdos ]; then
	  cat << EOF
	parttool \${root} hidden-
EOF
      fi
      case ${LONGNAME} in
	Windows\ Vista*|Windows\ 7*|Windows\ Server\ 2008*)
	;;
	*)
	  cat << EOF
	drivemap -s (hd0) \${root}
EOF
	;;
      esac
      cat <<EOF
	chainloader +1
}
EOF
    ;;
    efi)
	found_other_os=1
	EFIPATH=${DEVICE#*@}
	DEVICE=${DEVICE%@*}
	onstr="$(gettext_printf "(on %s)" "${DEVICE}")"
      cat << EOF
menuentry '$(echo "${LONGNAME} $onstr" | grub_quote)' $CLASS --class os \$menuentry_id_option 'osprober-efi-$(grub_get_device_id "${DEVICE}")' {
EOF
      save_default_entry | sed -e "s/^/\t/"
      prepare_grub_to_access_device ${DEVICE} | sed -e "s/^/\t/"
      cat <<EOF
	chainloader ${EFIPATH}
}
EOF
    ;;
    linux)
      if [ "x$BTRFS" = "xbtrfs" ]; then
         LINUXPROBED="`linux-boot-prober btrfs ${BTRFSuuid} ${BTRFSsubvol}  2> /dev/null | tr ' ' '^' | paste -s -d ' '`"
      else
         LINUXPROBED="`linux-boot-prober ${DEVICE} 2> /dev/null | tr ' ' '^' | paste -s -d ' '`"
      fi
      prepare_boot_cache=
      boot_device_id=
      is_top_level=true
      title_correction_code=
      OS="${LONGNAME}"
      for LINUX in ${LINUXPROBED} ; do
        LROOT="`echo ${LINUX} | cut -d ':' -f 1`"
        LBOOT="`echo ${LINUX} | cut -d ':' -f 2`"
        LLABEL="`echo ${LINUX} | cut -d ':' -f 3 | tr '^' ' '`"
        LKERNEL="`echo ${LINUX} | cut -d ':' -f 4`"
        LINITRD="`echo ${LINUX} | cut -d ':' -f 5`"
        LPARAMS="`echo ${LINUX} | cut -d ':' -f 6- | tr '^' ' '`"
        if [ -z "${LLABEL}" ] ; then
          LLABEL="${LONGNAME}"
        fi
	if [ "${LROOT}" != "${LBOOT}" ]; then
	  LKERNEL="${LKERNEL#/boot}"
	  LINITRD="${LINITRD#/boot}"
	fi
	if [ -z "${prepare_boot_cache}" ]; then
	  prepare_boot_cache="$(prepare_grub_to_access_device ${LBOOT} | grub_add_tab)"
	  [ "${prepare_boot_cache}" ] || continue
	fi
	found_other_os=1
	onstr="$(gettext_printf "(on %s)" "${DEVICE}")"
	recovery_params="$(echo "${LPARAMS}" | grep 'single\|recovery')" || true
	counter=1
	while echo "$used_osprober_linux_ids" | grep 'osprober-gnulinux-$LKERNEL-${recovery_params}-$counter-$boot_device_id' > /dev/null; do
	    counter=$((counter+1));
	done
	if [ -z "$boot_device_id" ]; then
	    boot_device_id="$(grub_get_device_id "${DEVICE}")"
	fi
	used_osprober_linux_ids="$used_osprober_linux_ids 'osprober-gnulinux-$LKERNEL-${recovery_params}-$counter-$boot_device_id'"
	if [ "x$is_top_level" = xtrue ] && [ "x${GRUB_DISABLE_SUBMENU}" != xy ]; then
            cat << EOF
menuentry '$(echo "$OS $onstr" | grub_quote)' $CLASS --class gnu-linux --class gnu --class os \$menuentry_id_option 'osprober-gnulinux-simple-$boot_device_id' {
EOF
	    save_default_entry | grub_add_tab
	    printf '%s\n' "${prepare_boot_cache}"
	    cat <<  EOF
	linux ${LKERNEL} ${LPARAMS}
EOF
            if [ -n "${LINITRD}" ] ; then
          cat << EOF
	initrd ${LINITRD}
EOF
            fi
        cat << EOF
}
EOF
	    echo "submenu '$(gettext_printf "Advanced options for %s" "${OS} $onstr" | grub_quote)' \$menuentry_id_option 'osprober-gnulinux-advanced-$boot_device_id' {"
	    is_top_level=false
	fi
	title="${LLABEL} $onstr"
        cat << EOF
	menuentry '$(echo "$title" | grub_quote)' --class gnu-linux --class gnu --class os \$menuentry_id_option 'osprober-gnulinux-$LKERNEL-${recovery_params}-$boot_device_id' {
EOF
	save_default_entry | sed -e "s/^/$grub_tab$grub_tab/"
	printf '%s\n' "${prepare_boot_cache}" | grub_add_tab
	cat <<  EOF
		linux ${LKERNEL} ${LPARAMS}
EOF
        if [ -n "${LINITRD}" ] ; then
            cat << EOF
		initrd ${LINITRD}
EOF
        fi
        cat << EOF
	}
EOF
	if [ x"$title" = x"$GRUB_ACTUAL_DEFAULT" ] || [ x"Previous Linux versions>$title" = x"$GRUB_ACTUAL_DEFAULT" ]; then
	    replacement_title="$(echo "Advanced options for ${OS} $onstr" | sed 's,>,>>,g')>$(echo "$title" | sed 's,>,>>,g')"
	    quoted="$(echo "$GRUB_ACTUAL_DEFAULT" | grub_quote)"
	    title_correction_code="${title_correction_code}if [ \"x\$default\" = '$quoted' ]; then default='$(echo "$replacement_title" | grub_quote)'; fi;"
	    grub_warn "$(gettext_printf "Please don't use old title \`%s' for GRUB_DEFAULT, use \`%s' (for versions before 2.00) or \`%s' (for 2.00 or later)" "$GRUB_ACTUAL_DEFAULT" "$replacement_title" "gnulinux-advanced-$boot_device_id>gnulinux-$version-$type-$boot_device_id")"
	fi
      done
      if [ x"$is_top_level" != xtrue ]; then
	  echo '}'
      fi
      echo "$title_correction_code"
    ;;
    macosx)
      if [ "${UUID}" ]; then
	OSXUUID="${UUID}"
	osx_entry xnu_kernel 32
	osx_entry xnu_kernel64 64
      fi
    ;;
    hurd)
      found_other_os=1
      onstr="$(gettext_printf "(on %s)" "${DEVICE}")"
      cat << EOF
menuentry '$(echo "${LONGNAME} $onstr" | grub_quote)' --class hurd --class gnu --class os \$menuentry_id_option 'osprober-gnuhurd-/boot/gnumach.gz-false-$(grub_get_device_id "${DEVICE}")' {
EOF
      save_default_entry | grub_add_tab
      prepare_grub_to_access_device ${DEVICE} | grub_add_tab
      grub_device="`${grub_probe} --device ${DEVICE} --target=drive`"
      mach_device="`echo "${grub_device}" | sed -e 's/(\(hd.*\),msdos\(.*\))/\1s\2/'`"
      grub_fs="`${grub_probe} --device ${DEVICE} --target=fs`"
      case "${grub_fs}" in
	*fs)	hurd_fs="${grub_fs}" ;;
	*)	hurd_fs="${grub_fs}fs" ;;
      esac
      cat << EOF
	multiboot /boot/gnumach.gz root=device:${mach_device}
	module /hurd/${hurd_fs}.static ${hurd_fs} --readonly \\
			--multiboot-command-line='\${kernel-command-line}' \\
			--host-priv-port='\${host-port}' \\
			--device-master-port='\${device-port}' \\
			--exec-server-task='\${exec-task}' -T typed '\${root}' \\
			'\$(task-create)' '\$(task-resume)'
	module /lib/ld.so.1 exec /hurd/exec '\$(exec-task=task-create)'
}
EOF
    ;;
    minix)
	  cat << EOF
menuentry "${LONGNAME} (on ${DEVICE}, Multiboot)" {
EOF
         save_default_entry | sed -e "s/^/\t/"
         prepare_grub_to_access_device ${DEVICE} | sed -e "s/^/\t/"
	 cat << EOF
	multiboot /boot/image_latest
}
EOF
    ;;
    *)
      # TRANSLATORS: %s is replaced by OS name.
      gettext_printf "%s is not yet supported by grub-mkconfig.\n" "  ${LONGNAME}" >&2
    ;;
  esac
done
adjust_timeout

======================= sda8/etc/grub.d/37_uefi-firmware =======================

#! /bin/sh
set -e
# grub-mkconfig helper script.
# Copyright (C) 2012  Free Software Foundation, Inc.
#
# GRUB is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# GRUB is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
prefix="/usr"
exec_prefix="/usr"
datarootdir="/usr/share"
export TEXTDOMAIN=grub
export TEXTDOMAINDIR="${datarootdir}/locale"
. "${datarootdir}/grub/grub-mkconfig_lib"
efi_vars_dir=/sys/firmware/efi/vars
EFI_GLOBAL_VARIABLE=8be4df61-93ca-11d2-aa0d-00e098032b8c
OsIndications="$efi_vars_dir/OsIndicationsSupported-$EFI_GLOBAL_VARIABLE/data"
if [ -e "$OsIndications" ] && \
   [ "$(( $(printf 0x%x \'"$(cat $OsIndications | cut -b1)") & 1 ))" = 1 ]; then
  LABEL="UEFI Firmware Settings"
  gettext_printf "Adding boot menu entry for UEFI Firmware Settings\n" >&2
  onstr="$(gettext_printf "(on %s)" "${DEVICE}")"
  cat << EOF
menuentry '$LABEL' \$menuentry_id_option 'uefi-firmware' {
	fwsetup
}
EOF
fi

===================== sda11/boot/grub/grub.cfg (filtered) ======================

Ubuntu   006957ca-3a1d-4ca5-8aef-7dc4449773bf
Ubuntu, with Linux 5.4.0-54-generic   006957ca-3a1d-4ca5-8aef-7dc4449773bf
Ubuntu, with Linux 5.4.0-42-generic   006957ca-3a1d-4ca5-8aef-7dc4449773bf
Ubuntu 20.04.1 LTS (20.04) (on sda8)   355877ac-471e-4427-9175-52b7b339dc00
Ubuntu (on sda8)   355877ac-471e-4427-9175-52b7b339dc00
Ubuntu, with Linux 5.4.0-53-generic (on sda8)   355877ac-471e-4427-9175-52b7b339dc00
Ubuntu, with Linux 5.4.0-52-generic (on sda8)   355877ac-471e-4427-9175-52b7b339dc00
### END /etc/grub.d/30_os-prober ###
### END /etc/grub.d/30_uefi-firmware ###

========================== sda11/etc/fstab (filtered) ==========================

# <file system> <mount point>   <type>  <options>       <dump>  <pass>
# / was on /dev/sda11 during installation
UUID=006957ca-3a1d-4ca5-8aef-7dc4449773bf /               ext4    errors=remount-ro 0       1
# /boot/efi was on /dev/sda10 during installation
UUID=E306-40CD  /boot/efi       vfat    umask=0077      0       1
/swapfile                                 none            swap    sw              0       0

====================== sda11/etc/default/grub (filtered) =======================

GRUB_DEFAULT=0
GRUB_TIMEOUT_STYLE=hidden
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=""

=================== sda11: Location of files loaded by Grub ====================

           GiB - GB             File                                 Fragment(s)
 138.983386993 = 149.232275456  boot/grub/grub.cfg                             2
 133.103698730 = 142.919008256  boot/grub/i386-pc/core.img                     1
 132.672985077 = 142.456532992  boot/vmlinuz                                   1
 129.805782318 = 139.377897472  boot/vmlinuz-5.4.0-42-generic                  1
 132.672985077 = 142.456532992  boot/vmlinuz-5.4.0-54-generic                  1
 129.805782318 = 139.377897472  boot/vmlinuz.old                               1
 135.325874329 = 145.305051136  boot/initrd.img                                3
 134.835300446 = 144.778301440  boot/initrd.img-5.4.0-42-generic               3
 133.513339996 = 143.358857216  boot/initrd.img-5.4.0-42-generic.old-dkms      2
 135.325874329 = 145.305051136  boot/initrd.img-5.4.0-54-generic               3
 134.716499329 = 144.650739712  boot/initrd.img-5.4.0-54-generic.old-dkms      3
 134.835300446 = 144.778301440  boot/initrd.img.old                            3

===================== sda11: ls -l /etc/grub.d/ (filtered) =====================

-rwxr-xr-x 1 root root 17622 Oct  1 20:49 10_linux
-rwxr-xr-x 1 root root 42359 Oct  1 20:49 10_linux_zfs
-rwxr-xr-x 1 root root 12894 Jul 31 06:04 20_linux_xen
-rwxr-xr-x 1 root root 12059 Jul 31 06:04 30_os-prober
-rwxr-xr-x 1 root root  1424 Jul 31 06:04 30_uefi-firmware
-rwxr-xr-x 1 root root   214 Jul 31 06:04 40_custom
-rwxr-xr-x 1 root root   216 Jul 31 06:04 41_custom


Error code 12
mount -r /dev/sda3 /mnt/boot-sav/sda3

mount -r /dev/sda3 : Error code 12
Error code 12
mount -r /dev/sda3 /mnt/boot-sav/sda3

mount -r /dev/sda3 : Error code 12
Suggested repair: ______________________________________________________________

The default repair of the Boot-Repair utility would reinstall the grub2 of
sda11 into the MBR of sda.
Additional repair would be performed: unhide-bootmenu-10s      

Blockers in case of suggested repair: __________________________________________

 GPT detected. Please create a BIOS-Boot partition (>1MB, unformatted filesystem, bios_grub flag). This can be performed via tools such as Gparted. Then try again.


